---
layout:     post
title:      OpenGL入门概念介绍
date:       2025-08-01
subtitle:   OpenGL入门概念：渲染模式、扩展、状态机、对象
categories: OpenGL 学习
author:     蓝
catalog: true
tags: 
  - OpenGL
  - 图形学
---

# OpenGL入门概念介绍

- [渲染模式](#渲染模式)
- [扩展](#扩展)
- [状态机](#状态机)
- [对象](#对象)

## 渲染模式

### 立即渲染模式

早期的OpenGL使用立即渲染模式（固定管线）

**优点：** 绘制方便，易于理解和上手
**缺点：** 灵活性差，效率低，难以管理大量数据。

随着时间推移，从 OpenGL 3.2 开始，规范文档开始<font style ="color:#007acc; font-weight:bold;"><b>废弃</b></font>立即渲染模式，并鼓励开发者在 OpenGL 的核心模式（Core-profile）下进行开发，这个分支的规范完全移除了旧的特性。

### 核心模式

现代的OpenGL采用核心模式。

当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。

| 模式         | 优点                                                         | 缺点                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 立即渲染模式 | 易于学习和上手，抽象掉了很多底层细节，适合初学者快速体验图形绘制 | 很难理解OpenGL底层如何运作，灵活性和效率较低，难以管理复杂场景 |
| 核心模式     | 需要真正理解OpenGL和图形编程原理，灵活性高，效率更好，有助于深入掌握图形开发 | 学习曲线较陡，初学者上手有一定难度，需要手动管理更多细节       |

**举例：**  
- 立即渲染模式下，绘制一个三角形只需 `glBegin(GL_TRIANGLES)`、`glVertex3f(...)`、`glEnd()`，无需关心数据如何传递到GPU。  
- 核心模式下，必须创建缓冲区对象（如VBO）、编写着色器、手动上传数据，这要求开发者理解GPU管线和数据流，但也能实现更复杂和高效的渲染效果。

## 扩展

OpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。如果一个程序在支持这个扩展的显卡上运行，开发者可以使用这个扩展提供的一些更先进更有效的图形功能。通过这种方式，开发者不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性了，只需要简单地检查一下显卡是否支持此扩展。通常，当一个扩展非常流行或者非常有用的时候，它将最终成为未来的OpenGL规范的一部分。

通常结构如下：

```c
// 检查扩展是否支持
const char* extensions = (const char*)glGetString(GL_EXTENSIONS);
if (strstr(extensions, "GL_ARB_vertex_program")) {
  // 支持该扩展，可以安全调用相关API
  // 例如：glGenProgramsARB, glBindProgramARB 等
} else {
  // 不支持该扩展，需降级处理
}
```

或

```c
if(GL_ARB_extension_name)
{
    // 使用硬件支持的全新的现代特性
}
else
{
    // 不支持此扩展: 用旧的方式去做
}
```

在现代OpenGL中（3.0及以上），推荐使用如下方式查询扩展：

```c
int numExtensions = 0;
glGetIntegerv(GL_NUM_EXTENSIONS, &numExtensions);
for (int i = 0; i < numExtensions; ++i) {
  const char* ext = (const char*)glGetStringi(GL_EXTENSIONS, i);
  if (strcmp(ext, "GL_ARB_vertex_program") == 0) {
    // 找到目标扩展
  }
}
```

通过这种方式，开发者可以灵活地利用新特性，同时保证程序的兼容性和可移植性。


## 状态机

OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL<font color="#008000">上下文</font>(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。

假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。

当使用OpenGL的时候，我们会遇到一些<font color="#008000">状态设置函数</font>(State-changing Function)，这类函数将会改变上下文。以及状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。**只要你记住OpenGL本质上是个大状态机，就能更容易理解它的大部分特性。**

## 对象

OpenGL库是用C语言写的，且由于C的一些语言结构不易被翻译到其他高级语言，所以引入了一层抽象，“对象(Object)”就是其中一个。

在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集，可以把对象理解为C风格的一个结构体(Struct):

```c
struct object_name {
    float  option1;
    int    option2;
    char[] name;
};
```

使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。

### 示例：使用缓冲区对象（VBO）管理不同几何体

假设我们需要在同一个场景中渲染一个三角形和一个正方形。我们可以为每个几何体分别创建自己的顶点缓冲区对象（VBO），这样可以独立管理它们的数据和状态。

```c
GLuint triangleVBO, squareVBO;

// 创建三角形的VBO
glGenBuffers(1, &triangleVBO);
glBindBuffer(GL_ARRAY_BUFFER, triangleVBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(triangleVertices), triangleVertices, GL_STATIC_DRAW);

// 创建正方形的VBO
glGenBuffers(1, &squareVBO);
glBindBuffer(GL_ARRAY_BUFFER, squareVBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(squareVertices), squareVertices, GL_STATIC_DRAW);

// 渲染时切换VBO
// 绘制三角形
glBindBuffer(GL_ARRAY_BUFFER, triangleVBO);
// 设置顶点属性指针并绘制...

// 绘制正方形
glBindBuffer(GL_ARRAY_BUFFER, squareVBO);
// 设置顶点属性指针并绘制...
```

通过这种方式，每个对象（如VBO、纹理、帧缓冲等）都可以独立配置和管理，极大提升了程序的灵活性和可维护性。

### 常见的OpenGL对象类型

- 缓冲区对象（Buffer Object）：如VBO、EBO等，用于存储顶点、索引等数据。
- 纹理对象（Texture Object）：用于存储和管理纹理数据。
- 着色器对象（Shader Object）：用于管理着色器程序。
- 帧缓冲对象（Framebuffer Object）：用于离屏渲染和后处理。

通过合理使用对象，OpenGL程序可以高效地组织和切换各种渲染资源，实现复杂的图形效果。